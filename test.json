{
    "took": 16,
    "timed_out": false,
    "_shards": {
        "total": 1,
        "successful": 1,
        "skipped": 0,
        "failed": 0
    },
    "hits": {
        "total": {
            "value": 2,
            "relation": "eq"
        },
        "max_score": 11.275922,
        "hits": [
            {
                "_index": "pages",
                "_type": "_doc",
                "_id": "cXVhcmt1c2d1aWRlcyNodHRwczovL3F1YXJrdXMuaW8vZ3VpZGVzL2NvbmZpZw==",
                "_score": 11.275922,
                "_ignored": [
                    "page-text.keyword"
                ],
                "_source": {
                    "id": "cXVhcmt1c2d1aWRlcyNodHRwczovL3F1YXJrdXMuaW8vZ3VpZGVzL2NvbmZpZw%3D%3D",
                    "page-text": "About WHAT IS QUARKUS? CONTAINER FIRST REACTIVE DEVELOPER JOY KUBERNETES NATIVE STANDARDS Learn GET STARTED GUIDES \"Q\" TIP VIDEOS BOOKS Community SUPPORT BLOG DISCUSSION PODCAST EVENTS NEWSLETTER PUBLICATIONS AWARDS Start Coding OFFICIAL (ENGLISH) ESPAÑOL 简体中文 日本語 Back to Guides Select Guide Version Main - SNAPSHOT 2.11 - Latest 2.7 2.2 1.11 Configuring Your Application Prerequisites Solution Create the Maven project Create the configuration Create a REST resource Inject the configuration Update the test Package and run the application Programmatically access the configuration Configuring Quarkus Build Time configuration Additional Information The content of this guide and been revised and split into additional topics. Please check the Additional Information section. Hardcoded values in your code are a no-go (even if we all did it at some point ;-)). In this guide, we will learn how to configure a Quarkus application. Prerequisites To complete this guide, you need: Roughly 15 minutes An IDE JDK 11+ installed with JAVA_HOME configured appropriately Apache Maven 3.8.1+ Optionally the Quarkus CLI if you want to use it Optionally Mandrel or GraalVM installed and configured appropriately if you want to build a native executable (or Docker if you use a native container build) Solution We recommend that you follow the instructions in the next sections and create the application step by step. However, you can go right to the completed example. Clone the Git repository: git clone https://github.com/quarkusio/quarkus-quickstarts.git, or download an archive. The solution is located in the config-quickstart directory. Create the Maven project First, we need a new project. Create a new project with the following command: CLI quarkus create app org.acme:config-quickstart \\    --extension=resteasy-reactive \\    --no-codecd config-quickstart To create a Gradle project, add the --gradle or --gradle-kotlin-dsl option. For more information about how to install the Quarkus CLI and use it, please refer to the Quarkus CLI guide. Maven mvn io.quarkus.platform:quarkus-maven-plugin:2.11.3.Final:create \\    -DprojectGroupId=org.acme \\    -DprojectArtifactId=config-quickstart \\    -Dextensions=\"resteasy-reactive\" \\    -DnoCodecd config-quickstart To create a Gradle project, add the -DbuildTool=gradle or -DbuildTool=gradle-kotlin-dsl option. It generates: the Maven structure a landing page accessible on http://localhost:8080 example Dockerfile files for both native and jvm modes the application configuration file Create the configuration A Quarkus application uses the SmallRye Config API to provide all mechanisms related with configuration. By default, Quarkus reads configuration properties from several sources. For the purpose of this guide, we will use an application configuration file located in src/main/resources/application.properties. Edit the file with the following content: application.properties # Your configuration propertiesgreeting.message = hellogreeting.name = quarkus Create a REST resource Create the org.acme.config.GreetingResource REST resource with the following content: package org.acme.config;import javax.ws.rs.GET;import javax.ws.rs.Path;import javax.ws.rs.Produces;import javax.ws.rs.core.MediaType;@Path(\"/greeting\")public class GreetingResource {    @GET    @Produces(MediaType.TEXT_PLAIN)    public String hello() {        return \"Hello RESTEasy\";    }} Inject the configuration Quarkus uses MicroProfile Config annotations to inject the configuration properties in the application. @ConfigProperty(name = \"greeting.message\") (1)String message; 1 You can use @Inject @ConfigProperty or just @ConfigProperty. The @Inject annotation is not necessary for members annotated with @ConfigProperty. If the application attempts to inject a configuration property that is not set, an error is thrown. Edit the org.acme.config.GreetingResource, and introduce the following configuration properties: @ConfigProperty(name = \"greeting.message\") (1)String message;@ConfigProperty(name = \"greeting.suffix\", defaultValue=\"!\") (2)String suffix;@ConfigProperty(name = \"greeting.name\")Optional<String> name; (3) 1 If you do not provide a value for this property, the application startup fails with javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message. 2 The default value is injected if the configuration does not provide a value for greeting.suffix. 3 This property is optional - an empty Optional is injected if the configuration does not provide a value for greeting.name. Now, modify the hello method to use the injected properties: @GET@Produces(MediaType.TEXT_PLAIN)public String hello() {    return message + \" \" + name.orElse(\"world\") + suffix;} Use @io.smallrye.config.ConfigMapping annotation to group multiple configurations in a single interface. Please, check the Config Mappings documentation. Update the test We also need to update the functional test to reflect the changes made to the endpoint. Create the src/test/java/org/acme/config/GreetingResourceTest.java file with the following content: package org.acme.config;import io.quarkus.test.junit.QuarkusTest;import org.junit.jupiter.api.Test;import static io.restassured.RestAssured.given;import static org.hamcrest.CoreMatchers.is;@QuarkusTestpublic class GreetingResourceTest {    @Test    public void testHelloEndpoint() {        given()          .when().get(\"/greeting\")          .then()             .statusCode(200)             .body(is(\"hello quarkus!\")); // Modified line    }} Package and run the application Run the application with: CLI quarkus dev Maven ./mvnw quarkus:dev Gradle ./gradlew --console=plain quarkusDev Open your browser to http://localhost:8080/greeting. Changing the configuration file is immediately reflected. You can add the greeting.suffix, remove the other properties, change the values, etc. As usual, the application can be packaged using: CLI quarkus build Maven ./mvnw clean package Gradle ./gradlew build and executed using java -jar target/quarkus-app/quarkus-run.jar. You can also generate the native executable with: CLI quarkus build --native Maven ./mvnw package -Dnative Gradle ./gradlew build -Dquarkus.package.type=native Programmatically access the configuration The org.eclipse.microprofile.config.ConfigProvider.getConfig() API allows to access the Config API programmatically. This API is mostly useful in situations where CDI injection is not available. String databaseName = ConfigProvider.getConfig().getValue(\"database.name\", String.class);Optional<String> maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue(\"database.name\", String.class); Configuring Quarkus Quarkus itself is configured via the same mechanism as your application. Quarkus reserves the quarkus. namespace for its own configuration. For example to configure the HTTP server port you can set quarkus.http.port in application.properties. All the Quarkus configuration properties are documented and searchable. As mentioned above, properties prefixed with quarkus. are effectively reserved for configuring Quarkus itself and its extensions. Therefore, the quarkus. prefix should never be used for application specific properties. Build Time configuration Some Quarkus configurations only take effect during build time, meaning is not possible to change them at runtime. These configurations are still available at runtime but as read-only and have no effect in Quarkus behaviour. A change to any of these configurations requires a rebuild of the application itself to reflect changes of such properties. The properties fixed at build time are marked with a lock icon () in the list of all configuration options. However, some extensions do define properties overridable at runtime. A simple example is the database URL, username and password which is only known specifically in your target environment, so they can be set and influence the application behaviour at runtime. Additional Information Configuration Reference Guide YAML ConfigSource Extension HashiCorp Vault ConfigSource Extension Consul ConfigSource Extension Spring Cloud ConfigSource Extension Mapping configuration to objects Extending configuration support Quarkus relies on SmallRye Config and inherits its features: Additional ConfigSources Additional Converters Indexed properties Parent profile Interceptors for configuration value resolution Relocate configuration properties Fallback configuration properties Logging Hide secrets For more information, please check the SmallRye Config documentation. Quarkus is open. All dependencies of this project are available under the Apache Software License 2.0 or compatible license. This website was built with Jekyll, is hosted on GitHub Pages and is completely open source. If you want to make it better, fork the website and show us what you’ve got. Navigation Home About Blog Podcast Events Newsletter Publications Awards Security policy Follow Us Twitter Facebook Linkedin Youtube GitHub Get Help Support Guides FAQ Get Started Stack Overflow Discussions Development mailing list Languages English Español 简体中文 日本語 Quarkus is made of community projects Eclipse Vert.x SmallRye Hibernate Netty RESTEasy Apache Camel Eclipse MicroProfile And many more... CC by 3.0 | Privacy Policy Sponsored by",
                    "site-id": "quarkusguides",
                    "title": "Configuring Your Application - Quarkus",
                    "url": "https://quarkus.io/guides/config"
                },
                "highlight": {
                    "page-text": [
                        "Your Application Prerequisites Solution Create the Maven project Create the configuration Create a REST",
                        "ENGLISH) ESPAÑOL 简体中文 日本語 Back to Guides Select Guide Version Main - SNAPSHOT 2.11 - Latest 2.7 2.2 1.11 Configuring"
                    ],
                    "title": [
                        "Configuring Your Application - Quarkus"
                    ]
                }
            },
            {
                "_index": "pages",
                "_type": "_doc",
                "_id": "cXVhcmt1c2d1aWRlcyNodHRwczovL3F1YXJrdXMuaW8vZ3VpZGVz",
                "_score": 0.8708761,
                "_ignored": [
                    "page-text.keyword"
                ],
                "_source": {
                    "id": "cXVhcmt1c2d1aWRlcyNodHRwczovL3F1YXJrdXMuaW8vZ3VpZGVz",
                    "page-text": "About WHAT IS QUARKUS? CONTAINER FIRST REACTIVE DEVELOPER JOY KUBERNETES NATIVE STANDARDS Learn GET STARTED GUIDES \"Q\" TIP VIDEOS BOOKS Community SUPPORT BLOG DISCUSSION PODCAST EVENTS NEWSLETTER PUBLICATIONS AWARDS Start Coding OFFICIAL (ENGLISH) ESPAÑOL 简体中文 日本語 Guides - Latest Select Guides Version Main - SNAPSHOT 2.11 - Latest 2.7 2.2 1.11 View Category Getting Started Core Web Data Messaging Security Business Automation Integration Command Line Applications Cloud Observability Serialization Tooling Compatibility Miscellaneous Alternative Languages Writing Extensions Architecture Quarkus Cheat Sheet Download full cheatsheet as PDF Get more cheatsheets on the Red Hat Developers website Getting Started Be Guided Through First Application Discover how to create your first Quarkus application. Getting Started with Reactive Learn more about developing reactive applications with Quarkus. Building Native Executables Build native executables with GraalVM or Mandrel. Using our Tooling Explore the Quarkus developer toolchain which makes Quarkus development so fast and enjoyable. Quarkus Tools in your favorite IDE Learn more about Quarkus integrations in IDEs. Core Configuring Your Application Hardcoded values in your code is a no go (even if we all did it at some point ;-)). In this guide, we learn how to configure your application. Configuration Reference Learn more about how to configure your Quarkus applications. Mapping Configuration to Objects Group multiple configuration properties into an object. Extending Configuration Support Extend and customize the Configuration. YAML Configuration YAML as a Configuration Source. All Configuration Properties List all the configuration properties per extensions Application Initialization and Termination You often need to execute custom actions when the application starts and clean up everything when the application stops. This guide explains how to be notified when an application stops or starts. lifecycle event Introduction to CDI Quarkus DI solution is based on the Contexts and Dependency Injection for Java 2.0 specification. This guide explains the basics of CDI. qualifier event interceptor observer arc CDI Reference Go more in depth into the Quarkus implementation of CDI. arc Mutiny, Reactive for Bare Mortals Learn more about how to develop reactive applications with Quarkus. Testing Your Application This guide covers: Testing in JVM mode Testing in native mode Injection of resources into tests Continuous Testing Get early test feedback with Continuous Testing. Automatic Service Setup with Dev Services A list of all extensions that support Dev Services and their configuration options. Configuring Logging This guide explains logging and how to configure it. Command Mode Reference This reference guide explains how to develop command line applications with Quarkus. Context Propagation Learn more about how you can pass contextual information with SmallRye Context Propagation. Using SSL With Native Executables In this guide, we will discuss how you can get your native executables to support SSL, as native executables don’t support it out of the box. Base Runtime Image for Native Executables Learn more about the base runtime image used by Quarkus for native executables and how you can tweak it. Compress Native Executables with UPX Learn how you can reduce the size of your native executables with UPX. Writing Native Applications This guide is a collection of tips to help you solve the problems you encounter when compiling applications to native executable. Native Reference Explore in more details how to debug native executables. Web Introduction to writing REST JSON Services JSON is now the lingua franca between microservices. In this guide, we see how you can get your REST services to consume and produce JSON payloads. Writing REST Services Reference Discover how to develop highly scalable REST services with JAX-RS and RESTEasy Reactive. Using the REST Client (including JSON) This guide explains how to use the RESTEasy Reactive REST Client. Migrating from RESTEasy Classic to RESTEasy Reactive This guide explains how to migrate an application from RESTEasy Classic to RESTEasy Reactive. Writing Simple REST CRUD Services Hibernate ORM REST Data with Panache simplifies the creation of CRUD applications based on JAX-RS and Hibernate ORM. Validation with Hibernate Validator This guide covers how to use Hibernate Validator/Bean Validation in your REST services. Using the REST Client with Multipart This guide explains how to use the RESTEasy REST Client to send multipart REST requests, typically to upload documents. Using WebSockets This guide explains how your Quarkus application can utilize web sockets to create interactive web applications. Because it’s the canonical web socket application, we are going to create a simple chat application. Using OpenAPI and Swagger UI This guide explains how to use the OpenAPI extension to generate an OpenAPI descriptor and get a Swagger UI frontend to test your REST endpoints. Developing REST Services with RESTEasy Classic This guide explains how to use the RESTEasy REST Client in order to interact with REST APIs (JSON and other) with very little effort. Using the RESTEasy Classic REST Client (including JSON) This guide explains how to use the RESTEasy REST Client in order to interact with REST APIs (JSON and other) with very little effort. HTTP Reference Documentation Learn more about configuring Quarkus’ Vert.x based HTTP layer - and Undertow if you are using servlets. Using Fault Tolerance This guide demonstrates how your Quarkus application can utilize the SmallRye Fault Tolerance specification through the SmallRye Fault Tolerance extension. Using Reactive Routes This guide demonstrates how to use reactive routes. Implementing GraphQL Services This guide explains how to leverage SmallRye GraphQL to implement GraphQL services. Consuming GraphQL Services This guide explains how to leverage SmallRye GraphQL Client to consume GraphQL services. Data Configuring your datasources With Quarkus, you can easily configure a datasource, or several if need be. Database Dev Services Automatically start database containers with Dev Services. Using Hibernate ORM and JPA Hibernate ORM is the de facto JPA implementation and offers you the full breath of an Object Relational Mapper. It works beautifully in Quarkus. Simplified Hibernate ORM with Panache Hibernate ORM is the de facto JPA implementation and offers you the full breadth of an Object Relational Mapper. It makes complex mappings possible, but it does not make simple and common mappings trivial. Panache focuses on making your entities trivial and fun to write. Simplified Hibernate ORM with Panache and Kotlin This explain the specifics of using Hibernate ORM with Panache in a Kotlin project. Hibernate Search + Elasticsearch Hibernate Search allows you to index your entities in an Elasticsearch cluster and easily offer full text search in all your Hibernate ORM-based applications. Using Transactions Quarkus comes with a Transaction Manager and uses it to coordinate and expose transactions to your applications. Each extension dealing with persistence will integrate with it for you. And you will explicitly interact with transactions via CDI. This guide will walk you through all that. Using Blaze-Persistence This guide explains how to use Blaze-Persistence to simplify your data and DTO layers. Validation with Hibernate Validator This guide covers how to use Hibernate Validator/Bean Validation in your REST services. Cache your application data This guide explains how to cache expensive method calls of your CDI beans using simple annotations. Schema Migration with Flyway This guide covers how to use the Flyway extension to manage your schema migrations. Schema Migration with Liquibase This guide covers how to use the Liquibase extension to manage your schema migrations. Reactive SQL Clients This guide covers how to use the Reactive SQL Clients in Quarkus. Using Hibernate Reactive Reactive API for Hibernate ORM Simplified Hibernate Reactive with Panache Simplified reactive ORM layer based on Hibernate Reactive. Using Infinispan Client Infinispan is an in memory data grid that allows running in a server outside of application processes. This extension provides functionality to allow the client that can connect to said server when running in Quarkus. Elasticsearch Clients This guide covers how to use an Elasticsearch cluster using the low level or high level REST clients. Elasticsearch Dev Services Start Elasticsearch automatically in dev and test modes. MongoDB Client This guide covers how to use MongoDB in Quarkus. Liquibase MongoDB Manage your MongoDB schema migrations with Liquibase. MongoDB with Panache This guide covers the usage of MongoDB using active records and repositories. MongoDB with Panache and Kotlin This guide covers the usage of MongoDB using active records and repositories in a Kotlin project. Redis Client This guide covers how to use a Redis datastore in Quarkus. Redis Reference Learn how to customize the Redis client to your needs. Redis Dev Services Start Redis automatically in dev and test modes. Neo4j Client This guide covers how to use the Neo4j graph database in Quarkus. Quarkiverse Hub Apache Cassandra Client This guide covers how to use the Apache Cassandra NoSQL database in Quarkus. Amazon DynamoDB This guide covers how to use the Amazon DynamoDB database in Quarkus. Quarkiverse Hub Amazon S3 This guide covers how to use the Amazon S3 cloud storage in Quarkus. Quarkiverse Hub Google Cloud BigQuery This guide covers how to use GCP BigQuery in Quarkus. Quarkiverse Hub Google Cloud Bigtable This guide covers how to use GCP Bigtable in Quarkus. Quarkiverse Hub Google Cloud Firestore This guide covers how to use GCP Firestore in Quarkus. Quarkiverse Hub Google Cloud Spanner This guide covers how to use GCP Spanner in Quarkus. Quarkiverse Hub Google Cloud Storage This guide covers how to use GCP Storage in Quarkus. Quarkiverse Hub Using Software Transactional Memory This guides covers the usage of Software Transactional Memory (STM). Using LRA (Long Running Actions) This guides covers the usage of LRA to coordinate activities across services. Messaging Getting Started to SmallRye Reactive Messaging with Apache Kafka This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with Apache Kafka. Apache Kafka Reference Guide This reference guide provides an in-depth look on Apache Kafka and Smallrye Reactive Messaging framework. Apache Kafka Dev Services Start Apache Kafka automatically in dev and test modes. Using Apache Kafka with Schema Registry and Avro Use Apache Kafka, Avro serialized records, and connect to a schema registry. Apicurio Registry Dev Services Start Apicurio Registry automatically in dev and test modes. Using AMQP with Reactive Messaging This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with AMQP. AMQP Reference Reference guide for SmallRye Reactive Messaging and AMQP. AMQP Dev Services Start AMQP automatically in dev and test modes. Using RabbitMQ with Reactive Messaging This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with RabbitMQ. RabbitMQ Reference Reference guide for SmallRye Reactive Messaging and RabbitMQ. RabbitMQ Dev Services Start RabbitMQ automatically in dev and test modes. Using HTTP with Reactive Messaging This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to consume and produce HTTP messages. Using WebSockets with Reactive Messaging This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to consume and produce messages via WebSockets. Using Apache Kafka Streams This guide demonstrates how your Quarkus application can utilize the Apache Kafka Streams API to implement stream processing applications based on Apache Kafka. Using the event bus This guide explains how different beans can interact using the event bus. Using JMS This guide demonstrates how your Quarkus application can use JMS messaging with AMQP 1.0 using Apache Qpid JMS, or using Apache ActiveMQ Artemis JMS. Google Cloud PubSub This guide covers how to use GCP PubSub in Quarkus. Quarkiverse Hub Security Security Overview This guide is the entry point for everything security in Quarkus. security Authorization of Web Endpoints Secure your web endpoints with authorizations. security Built-In Authentication Support Learn more about how Quarkus handles authentication. security Security Customization Customize Quarkus’ security layer behavior. security Security Testing Test the security of your Quarkus applications. security Using Security with .properties File This guide demonstrates how your Quarkus application can use a .properties file to store your user identities. security Using Security with JPA This guide demonstrates how your Quarkus application can use a database to store your user identities with Hibernate ORM. security Using Security with JDBC This guide demonstrates how your Quarkus application can use a database to store your user identities. security Using Security with LDAP This guide demonstrates how your Quarkus application can use a LDAP directory to store your user identities. security Using OpenID Connect (OIDC) to Protect Service Applications This guide demonstrates how to use the OpenID Connect extension to protect your Quarkus JAX-RS service application using Bearer Token Authorization where the tokens are issued by OpenID Connect Providers such as Keycloak. sso,jwt,security Using OpenID Connect (OIDC) to Protect Web Applications This guide demonstrates how to use the OpenID Connect extension to protect your Quarkus JAX-RS web application using the Authorization Code Flow and OpenID Connect Providers such as Keycloak. sso,security Using OpenID Connect (OIDC) Multi-Tenancy This guide demonstrates how your OpenID Connect application can support multi-tenancy so that you can serve multiple tenants from a single application. sso,security Using OpenID Connect (OIDC) and Keycloak to Centralize Authorizations This guide demonstrates how your Quarkus application can authorize access to protected resources using Keycloak Authorization Services. sso,security Using OpenID Connect (OIDC) and OAuth2 Client and Filters This guide explains how to use OpenID Connect and OAuth2 Client and Filters to acquire, refresh and propagate access tokens. sso,security OpenID Connect (OIDC) and OAuth2 Client and Filters Reference Reference guide for OpenID Connect and OAuth2 Client and Filters. sso,security Configuring Well-Known OpenID Connect (OIDC) Providers This guide explains how to configure Quarkus to authenticate against well-known OpenID Connect providers such as GitHub, Google, Microsoft, Apple… sso,security OpenID Connect (OIDC) Dev Services Start Keycloak or other providers automatically in dev and test modes. security Using JWT RBAC This guide explains how your application can utilize SmallRye JWT to verify JWT tokens and provide secured access to the JAX-RS endpoints. security Build, Sign and Encrypt JSON Web Tokens (JWT) This guide explains how your application can build, sign and/or encrypt JWT tokens with a fluent and configurable SmallRye JWT Build API. jwt,security Using OAuth2 RBAC This guide explains how your Quarkus application can utilize OAuth2 tokens to provide secured access to the JAX-RS endpoints. security Using Vault This guide explains how you can use HashiCorp Vault to securely store your credentials in Quarkus. security Quarkiverse Hub Using Vault Transit Secret Engine This guide explains how you can use HashiCorp Vault for “encryption as a service”. security Quarkiverse Hub Using HashiCorp Vault with Databases Keep confidential your database credentials by storing them in Vault. security Quarkiverse Hub Working with HashiCorp Vault’s Authentication This guide explains the various methods supported by Quarkus to authenticate to your Vault. security Quarkiverse Hub Using HashiCorp Vault’s PKI Secret Engine Generate X.509 certificates with Vault’s PKI Secret Engine. security Quarkiverse Hub Credentials Provider This guides explains how to use the Vault credentials provider or implement your own custom one. security Using Security with WebAuthn This guide demonstrates how your Quarkus application can use WebAuthn authentication instead of passwords. security,webauthn Business Automation Using Kogito to add business automation capabilities to an application This guide demonstrates how your Quarkus application can use Kogito to add business automation to power it up with business processes and rules. Using Kogito DMN support to add decision automation capabilities to an application Use Kogito to add business automation and power it up with DMN decision support. Using Kogito to add rule engine capabilities to an application Use Kogito to add DRL files with rules. Using Kogito to add prediction capabilities to an application Use Kogito to add business automation to power it up with predictions. Kogito Dev Services Start Kogito automatically in dev and test modes. Using AI to optimize a schedule with OptaPlanner This guide walks you through the process of creating a Quarkus application with OptaPlanner’s constraint solving Artificial Intelligence (AI). Integration Apache Camel This guide covers the systems integration with Apache Camel Command Line Applications Command Mode Reference This reference guide explains how to develop command line applications with Quarkus. Picocli Simplify command line applications creation with the Picocli extension. jbang Integration Easy Quarkus-based scripting with jbang. Cloud Service discovery and load balancing with Stork Learn how to use SmallRye Stork for service discovery and load balacing. Using Stork with Kubernetes Learn how to use SmallRye Stork in a Kubernetes environment. Stork Reference Have a more in-depth look at how SmallRye Stork can be configured and used. Build Container Images Learn how to build and push container images with Jib, S2I or Docker as part of the Quarkus build. Using Podman Use Podman instead of Docker for running containers. Deploying Quarkus Applications on Kubernetes This guide covers how to deploy a native application on Kubernetes. Deploying Quarkus Applications on OpenShift This guide covers how to deploy a native application on OpenShift. Consuming Kubernetes ConfigMaps Use ConfigMaps as a configuration source for your Quarkus applications. Using the Kubernetes Client to Interact with a Kubernetes Cluster This guide demonstrates how to use the Fabric8 Kubernetes client to interact with your Kubernetes cluster. Deploying to Microsoft Azure Cloud This guide explains how to deploy a Quarkus application to Microsoft Azure Cloud. Azure Functions (Serverless) with Vert.x Web, Servlet, or RESTEasy This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as an Azure Function. Amazon Lambda This guide explains how you can deploy Quarkus-based Amazon Lambdas. Amazon Lambda with Vert.x Web, Servlet, or RESTEasy This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as an Amazon Lambda. Deploying to Google Cloud This guide explains how to deploy a Quarkus application to Google Cloud. Google Cloud Functions This guide explains how you can deploy Quarkus-based Google Cloud Functions. Google Cloud Functions with Vert.x Web, Servlet, or RESTEasy This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as a Google Cloud Function. Deploying to Heroku Deploy your Quarkus applications on Heroku. Quarkus Funqy This guide explains basics of the Funqy framework, a simple portable cross-provider cloud function API. Quarkus Funqy HTTP This guide explains Funqy’s HTTP binding. Quarkus Funqy Amazon Lambdas This guide explains Funqy’s Amazon Lambda binding. Quarkus Funqy Amazon Lambdas HTTP This guide explains Funqy’s Amazon Lambda HTTP binding. Quarkus Funqy Knative Events This guide explains Funqy’s Knative Events binding. Quarkus Funqy Azure Functions HTTP This guide explains Funqy’s Azure Functions HTTP binding. Quarkus Funqy Google Cloud Platform This guide explains Funqy’s Google Cloud Platform Functions binding. Quarkus Funqy Google Cloud Platform HTTP This guide explains Funqy’s Google Cloud Platform Functions HTTP binding. Amazon DynamoDB This guide covers how to use the Amazon DynamoDB database in Quarkus. Quarkiverse Hub Amazon KMS This guide covers how to use the Amazon Key Management Service in Quarkus. Quarkiverse Hub Amazon IAM This guide covers how to use the Amazon Identity and Access Management in Quarkus. Quarkiverse Hub Amazon S3 This guide covers how to use the Amazon S3 cloud storage in Quarkus. Quarkiverse Hub Amazon SES This guide covers how to use the Amazon Simple Email Service in Quarkus. Quarkiverse Hub Amazon SNS This guide covers how to use the Amazon Simple Notification Service in Quarkus. Quarkiverse Hub Amazon SQS This guide covers how to use the Amazon Simple Queue Service in Quarkus. Quarkiverse Hub Amazon SSM This guide covers how to use the AWS Systems Manager in Quarkus. Quarkiverse Hub Access Google Cloud services This guide covers how to use multiple GCP services. Quarkiverse Hub Observability Using Health Check This guide demonstrates how your Quarkus application can utilize the SmallRye Health extension. Using OpenTelemetry This guide explains how your Quarkus application can utilize OpenTelemetry to provide distributed tracing for interactive web applications. Using OpenTracing This guide explains how your Quarkus application can utilize OpenTracing to provide distributed tracing for interactive web applications. Collecting Metrics with Micrometer This guide demonstrates how your Quarkus application can collect metrics using the Micrometer extension. Collecting Metrics with SmallRye Metrics This guide demonstrates how your Quarkus application can utilize the SmallRye Metrics extension. Using Fault Tolerance This guide demonstrates how your Quarkus application can utilize the SmallRye Fault Tolerance extension. Using Sentry to Monitor your Logs This guide explains how to use Sentry to monitor your application and be notified when exceptions occur. Quarkiverse Hub Centralized Log Management This guide explains how to centralize your logs with Logstash or Fluentd using the Graylog Extended Log Format (GELF). Serialization Writing REST JSON Services JSON is now the lingua franca between microservices. In this guide, we see how you can get your REST services to consume and produce JSON payloads. gRPC Entry point for everything gRPC. Getting Started with gRPC This guide explains how to start using gRPC in your Quarkus application. Implementing gRPC Services This guide explains how to implement gRPC services in your Quarkus application. Consuming gRPC Services This guide explains how to consume gRPC services in your Quarkus application. Tooling Using the Quarkus CLI Use the Quarkus CLI to create, build, run, and manage extensions for Quarkus projects. cli Building Applications with Maven This guide covers: Maven configuration Creating a new project Dealing with extensions Development mode Debugging Import in your IDE Building a native executable Build a container friendly executable Building Applications with Gradle This guide covers: Gradle configuration Creating a new project Dealing with extensions Development mode Debugging Import in your IDE Building a native executable Build a container friendly executable Releasing your Quarkus applications with JReleaser Discover how you can streamline the release process of your Quarkus applications with JReleaser. Measuring the coverage of your tests This guide explains how to measure the test coverage of your Quarkus application. Re-augment a Quarkus Application Use mutable jars to rebuild your application with different build time configurations. Compatibility Using the Quarkus Extension for Spring DI API While you are encouraged to use CDI annotations for injection, Quarkus provides a compatibility layer for Spring dependency injection in the form of the spring-di extension. Using the Quarkus Extension for Spring Web API While you are encouraged to use JAX-RS annotations for defining REST endpoints, Quarkus provides a compatibility layer for Spring Web in the form of the spring-web extension. Using the Quarkus Extension for Spring Data JPA API While you are encouraged to use Hibernate ORM with Panache for your data layer, Quarkus provides a compatibility layer for Spring Data JPA in the form of the spring-data-jpa extension. Writing Simple CRUD Applications with Spring Data Spring Data REST simplifies the creation of CRUD applications based on our Spring Data compatibility layer. Using the Quarkus Extension for Spring Security API While you are encouraged to use the Quarkus security layer to secure your applications, Quarkus provides a compatibility layer for Spring Security in the form of the spring-security extension. Using the Quarkus Extension for Spring Cache While you are encouraged to use the Cache extension for your application-level caching, Quarkus provides a compatibility layer for Spring Cache in the form of the spring-cache extension. Using the Quarkus Extension for Spring Scheduled While you are encouraged to use the Scheduler or Quartz extensions to schedule tasks, Quarkus provides a compatibility layer for Spring Scheduled in the form of the spring-scheduled extension. Using Spring Boot's ConfigurationProperties Use Spring Boot’s @ConfigurationProperties in place of MicroProfile Config annotations Using the Quarkus Extension for Spring Cloud Config Quarkus provides a compatibility layer for Spring Cloud Config in the form of the spring-cloud-config-client extension. Miscellaneous Scheduling Periodic Tasks Modern applications often need to run specific tasks periodically. In this guide, you learn how to schedule periodic tasks. Scheduler Reference Learn more about the Scheduler extension. Scheduling Clustered Tasks with Quartz You need clustering support for your scheduled tasks? This guide explains how to use the Quartz extension for that. Sending Emails using SMTP Learn more about how you can send email from a Quarkus application with our reactive email client. Mailer Reference Guide This reference guide explains in more details the configuration and usage of the Quarkus Mailer. Templating with Qute Learn more about how you can use templating in your applications with the Qute template engine. Qute Reference Guide Learn everything you need to know about the Qute template engine. Extracting Content with Apache Tika Learn more about how you extract content from documents using the Apache Tika toolkit. Quarkiverse Hub Using Vert.x This guide explains how to use Vert.x in Quarkus to build reactive applications. Vert.x Reference Guide This reference guide provides advanced details about the usage and the configuration of the Vert.x instance used by Quarkus. Access Git repositories with JGit This guide explains how you can access Git repositories with JGit. Quarkiverse Hub Consume Configuration from Consul This guide explains how your Quarkus application can read configuration properties at runtime from Consul. Quarkiverse Hub Measuring Performance This guide explains how to best measure the footprint of a Quarkus application. Consume Configuration from Google Cloud Secret Manager This guide covers how to use GCP Secret Manager in Quarkus to consume configuration properties directly or via your application.properties. Quarkiverse Hub Alternative Languages Using Kotlin This guide explains how to use Kotlin. Simplified Hibernate ORM with Panache and Kotlin This explain the specifics of using Hibernate ORM with Panache in a Kotlin project. MongoDB with Panache and Kotlin This guide covers the usage of MongoDB using active records and repositories in a Kotlin project. Writing Extensions Building My First Extension Learn step by step how to build a simple extension. CDI Integration Learn how to integrate your extension with Quarkus’ CDI container. Contributing to Dev UI Learn how to get your extension contribute features to the Dev UI. All BuildItems Explore all the BuildItems you can consume/produce in your extensions. Capabilities How capabilities are implemented and used in Quarkus. Conditional Extension Dependencies Trigger the inclusion on additional extensions based on certain conditions. Writing Your Own Extension Quarkus extensions optimize your applications by pushing as much work as possible to the build operation. This guide explains the rationale of Quarkus extensions and guides you through authoring your own extensions. Writing a Codestart for an extension Provide users with initial code for extensions when generating Quarkus applications on code.quarkus.io and all the Quarkus tooling. This guide explains how to create and configure a Codestart for an extension. Writing Native Applications This guide is a collection of tips to help you solve the problems you encounter when compiling applications to native executable. Architecture Quarkus Reactive Architecture Learn more about Quarkus reactive architecture. Class Loading Reference Learn more about Quarkus class loading infrastructure. Understanding the Platform concept Learn more about what we call a Platform in the Quarkus world. Quarkus Extension Registry Learn more about the notion of extension registry and how you can use your own. Dev Mode Differences How dev mode differs from a production application Sorry, no guides matched your search. Please try again. Quarkus is open. All dependencies of this project are available under the Apache Software License 2.0 or compatible license. This website was built with Jekyll, is hosted on GitHub Pages and is completely open source. If you want to make it better, fork the website and show us what you’ve got. Navigation Home About Blog Podcast Events Newsletter Publications Awards Security policy Follow Us Twitter Facebook Linkedin Youtube GitHub Get Help Support Guides FAQ Get Started Stack Overflow Discussions Development mailing list Languages English Español 简体中文 日本語 Quarkus is made of community projects Eclipse Vert.x SmallRye Hibernate Netty RESTEasy Apache Camel Eclipse MicroProfile And many more... CC by 3.0 | Privacy Policy Sponsored by",
                    "site-id": "quarkusguides",
                    "title": "Guides - Latest - Quarkus",
                    "url": "https://quarkus.io/guides"
                },
                "highlight": {
                    "page-text": [
                        "Core Configuring Your Application Hardcoded values in your code is a no go (even if we all did it at"
                    ]
                }
            }
        ]
    }
}